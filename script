import scipy.optimize._minimize
import numpy as np
import math
import matplotlib.pyplot as plt 


def make_fig():
    #
    # Creating figure
    fig = plt.figure(
        figsize=(5, 4.2),
        facecolor='#ffffff',
        tight_layout=True)
    # Adding and configuring axes
    ax = fig.add_subplot(
        facecolor='#ffffff',
        )
    ax.grid(
    linestyle=':',
    )
    # Returning axes handle
    return ax


def lengths( points, x3, y3):
    lengthArr = []
    lengthArr.append( math.sqrt( (points[0]**2) + (points[1]**2) ) )
    lengthArr.append( math.sqrt( ( points[2]- points[0] )**2 + ( points[3] - points[1] ) **2 ) )
    lengthArr.append( math.sqrt( (x3 - points[ 2 ] )**2 + ( y3 - points[3] )**2 ) )
    return lengthArr

def mass( a, l ):
    return a * l

def force( aMass ):
    return aMass * 9.81

def midpoints( positions, x3, y3 ):
    midpointArr = [ [], [], [] ]

    midpointArr[0].append( positions[0]/2 ) 
    midpointArr[0].append( positions[1]/2 )

    midpointArr[1].append( ( positions[2]-positions[0] )/2 + positions[0] )
    midpointArr[1].append( ( positions[3]-positions[1] )/2 + positions[1] )

    midpointArr[2].append( ( x3 - positions[2] )/2 + positions[2] )
    midpointArr[2].append( ( y3 - positions[3] )/2 + positions[3] )

    return midpointArr

def torque( positions ):

    posArray = [ 0, 0, 0 ]

    x3 = 0.75
    y3 = 0.1

    posArray[0] = positions[0]
    posArray[1] = positions[1]
    posArray[2] = positions[2]

    # print( "newY inside function ")
    # print( y3 - ( math.tan(-math.pi/3.0) * ( x3 - positions[2]) ) )

    posArray.append( y3 - ( math.tan(-math.pi/3.0) * (x3 - positions[2]) ) )

    # print("New addition to posArray:")
    # print( posArray)

    # 0.1 + ( math.tan(-math.pi/3.0) * (0.5+0.5) )
    
    lengthArr = lengths(posArray, x3, y3)

    masses = []
    a = 8
    for i in range( 0, 3):
        a /= 2
        masses.append( mass( a, lengthArr[i] ) )
    
    forces=[]
    for i in range( 0, 3 ):
        forces.append( force(masses[i]) )
    forces.append( force(5) )

    midpointArr = midpoints( posArray, x3, y3 )

    torque = 0

    for i in range( 0, 3):
        torque += ( forces[i] * midpointArr[i][0] * math.sin( math.atan2( midpointArr[i][1], midpointArr[i][0] ) ) )

    torque += forces[3] * x3 * math.sin( math.atan2( y3, x3 ) )

    make_fig()
    xPoints = [ 0, posArray[0], posArray[2], x3 ]
    yPoints = [ 0, posArray[1], posArray[3], y3 ]
    print(xPoints)
    print(yPoints)
    plt.scatter(xPoints, yPoints)
    plt.show()

    return math.fabs(torque)


x0 = [ -0.5, 0.5, 0.5 ]


test = torque(x0)
print(test)

res = scipy.optimize.minimize(torque, x0, method='Nelder-Mead')
print(res)

# newY = 0.1 - ( math.tan(-math.pi/3.0) * (0.5-(-0.5)) )
# print("NewY:")
# print(newY)

# print("Angle between point 2 and 3:")
# print ( math.atan2( 0.1 - newY, 0.5-(-0.5) ))
